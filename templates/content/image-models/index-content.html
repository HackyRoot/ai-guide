<!-- TOC --><a name="image-generation-guide"></a>
<h1 id="image-generation-guide">Image Generation Guide</h1>
<p>The goal of this guide is to help the curious reader understand the technical foundations, applications, and challenges of image generation. </p>
<p>This guide is neither a complete reference nor basic tutorial. It is meant to help you save time when getting started by providing an outline of the key ideas and linking high-quality reference material for further learning.</p>
<p>The initial sections are meant to be read in order, and serve as a gradual introduction to the topic. The final section (<a href="#diagrams-and-details">Diagrams and Details</a>) contains summarized explanations of key ideas. These will likely be most useful <em>after</em> the reader has become acquainted with the source material (linked in the <a href="#recommended-references">Recommended References</a> section). </p>
<!-- TOC start (generated with https://github.com/derlin/bitdowntoc) -->

<ul>
<li><a href="#what-is-image-generation">What is image generation?</a></li>
<li><a href="#what-are-diffusion-models">What are diffusion models?</a></li>
<li><a href="#challenges">Challenges</a><ul>
<li><a href="#selecting-a-base-model">Selecting a base model</a></li>
<li><a href="#conditioning-and-control">Conditioning and Control</a></li>
<li><a href="#consistency-for-video">Consistency for video</a></li>
<li><a href="#performance">Performance</a></li>
</ul>
</li>
<li><a href="#technical-foundations">Technical Foundations</a><ul>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#stable-diffusion-and-control-nets">Stable Diffusion and Control Nets</a></li>
<li><a href="#stable-diffusion-inference-diagram">Stable Diffusion Inference Diagram</a></li>
</ul>
</li>
<li><a href="#recommended-references">Recommended References</a></li>
<li><a href="#glossary">Glossary</a></li>
<li><a href="#diagrams-and-details">Diagrams and Details </a><ul>
<li><a href="#diffusion-model">Diffusion Model</a></li>
<li><a href="#autoencoder">Autoencoder</a></li>
<li><a href="#latent-diffusion-model">Latent Diffusion Model</a></li>
<li><a href="#variational-autoencoder-vae">Variational Autoencoder (VAE)</a></li>
<li><a href="#u-net">U-Net</a></li>
<li><a href="#clip-contrastive-language-image-pretraining">CLIP (Contrastive Language-Image Pretraining)</a></li>
<li><a href="#text-encoder">Text Encoder</a></li>
<li><a href="#control-net-conditioning-encoder">Control Net Conditioning Encoder</a></li>
<li><a href="#control-net-trainable-copy">Control Net Trainable Copy</a></li>
<li><a href="#low-rank-adaptation-lora">Low-Rank Adaptation (LoRA)</a></li>
<li><a href="#dreambooth">Dreambooth</a></li>
<li><a href="#textual-inversion">Textual Inversion</a></li>
<li><a href="#the-u-net-architecture-continued">The U-Net Architecture (continued)</a><ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#key-concepts">Key Concepts</a></li>
</ul>
</li>
<li><a href="#the-variational-autoencoder-vae-continued">The Variational Autoencoder (VAE) (continued)</a><ul>
<li><a href="#overview-1">Overview</a></li>
<li><a href="#key-concepts-1">Key Concepts</a></li>
</ul>
</li>
<li><a href="#noise-timesteps-schedulers">Noise, Timesteps, Schedulers</a><ul>
<li><a href="#overview-2">Overview</a></li>
<li><a href="#key-concepts-2">Key Concepts</a></li>
</ul>
</li>
<li><a href="#text-encoder-1">Text Encoder</a><ul>
<li><a href="#overview-3">Overview</a></li>
<li><a href="#key-concepts-3">Key Concepts</a></li>
</ul>
</li>
<li><a href="#fine-tuning-techniques">Fine-Tuning Techniques</a><ul>
<li><a href="#overview-4">Overview</a></li>
<li><a href="#key-concepts-4">Key Concepts</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- TOC end -->

<!-- TOC --><a name="what-is-image-generation"></a>
<h1 id="what-is-image-generation">What is image generation?</h1>
<p>Image generation refers to the process of creating images using pre-trained models.</p>
<p>You&#39;ve likely seen AI-generated images and <a href="https://www.youtube.com/watch?v=K10Ty0ZdbD8">videos</a> online. Maybe you&#39;ve generated your own images using applications like <a href="https://openai.com/research/dall-e-3-system-card"><code>DALL-E</code></a> or <a href="https://www.midjourney.com/"><code>MidJourney</code></a>. This guide can help you dive deeper.</p>
<figure>
<!-- <img src="/img/image-generation/pope_fake.jpg"> -->
<img src="/img/image-generation/screenshot_009.png">
<figcaption>This viral image of the pope wearing Balanciaga was generated by AI.</figcaption>
</figure>

<p>Image generation is a wide and active area of research. This guide focuses on a subset of essential topics:</p>
<ul>
<li><strong>Forward and reverse diffusion</strong>, the processes that enables today&#39;s popular <em>diffusion models</em> to generates images,</li>
<li><strong>Stable Diffusion</strong>, a flexible, open-source diffusion model architecture, and</li>
<li><strong>Challenges</strong> in achieving a desired visual style and meeting performance requirements (e.g. speed, memory).</li>
</ul>
<p>This guide does not attempt cover all topics. We omit or gloss over:</p>
<ul>
<li>Alternative neural network architectures for image generation like <code>GANs</code></li>
<li>Training details like hyperparameters, loss functions, and benchmarks</li>
<li>Environment setup, getting started, and hardware considerations</li>
<li>Neural Network fundamentals (e.g. stochastic gradient descent)</li>
</ul>
<p>This guide does not attempt to be complete or exhaustive. Rather, we hope that the specific topics covered provide a solid foundation for further learning.</p>
<!-- TOC --><a name="what-are-diffusion-models"></a>
<h1 id="what-are-diffusion-models">What are diffusion models?</h1>
<p><a href="https://en.wikipedia.org/wiki/Diffusion"><code>Diffusion</code></a> comes from the latin <em>diffundere</em>, meaning &quot;to spread out&quot;. It is the familiar process of things moving from higher concentration to lower concentration. </p>
<img src="/img/image-generation/screenshot_007.png">

<p>When purple dye is dropped into water, the dye <em>diffuses</em> until the entire mixture has a uniform purple hue. That is, until distribution of molecules from the purple dye is <a href="https://en.wikipedia.org/wiki/Continuous_uniform_distribution">uniformly random</a>.</p>
<img src="/img/image-generation/purple_diffusion.png">

<p><code>Diffusion models</code> are based on an analogous process. </p>
<p>First, we collect images that look like what we want our model to generate. Each image is like a drop of &quot;purple dye&quot;, rich in information and decidedly non-random. </p>
<img src="/img/image-generation/screenshot_010.png">

<p>Next, we add increasing levels of <a href="https://en.wikipedia.org/wiki/Gaussian_noise">noise</a> to each image. We continue this diffusion process until the information has been &quot;systematically destroyed&quot;. (That is, until the image has become uniform random noise.)</p>
<figure>
<img src="/img/image-generation/screenshot_011.png">
<figcaption>Forward-diffusion (noising)</figcaption>
</figure>

<p>Noisy images are paired with their originals to form a training data set. We use this data set to train a model to recover the <em>original</em> image given a noisy image. In other words, the model attempts to <a href="https://en.wikipedia.org/wiki/Noise_reduction">remove the noise</a> we added. </p>
<p>The model&#39;s loss function measures the difference between generated output and the original images, allowing us to improve the model parameters the usual way (stochastic gradient descent).</p>
<p>After training the model, we can use it to generate <em>new</em> images: If we start with <em>pure noise</em>, the model will &quot;denoise&quot; it into something that <em>looks like</em> it could be from the training set&#39;s original images.</p>
<figure>
<img src="/img/image-generation/screenshot_012.png">
<figcaption>Reverse-diffusion (denoising)</figcaption>
</figure>

<p>We&#39;ll discuss diffusion models in more detail in the <a href="#technical-foundations">Technical Foundations</a> section. First, let&#39;s consider some of the challenges we encounter when working with diffusion models. </p>
<!-- TOC --><a name="challenges"></a>
<h1 id="challenges">Challenges</h1>
<!-- TOC --><a name="selecting-a-base-model"></a>
<h2 id="selecting-a-base-model">Selecting a base model</h2>
<p>If you are like most developers, you will not need to train diffusion models <em>from scratch</em>. Instead, you will select a pre-trained base model and either use it for inference directly or fine-tune it to your needs. (We&#39;ll mention several viable methods of fine-tuning in a later section.)</p>
<p>Like any AI model, generative image models reflect biases in their training data. It is important to choose models whose training data, terms of use, and degree of openness are consistent with your values and needs.</p>
<p><a href="https://huggingface.co/models">Hugging Face</a> hosts a large collection of models available for free download. Each model has a model card that describes its origin, capabilities, limitations and terms of use.</p>
<figure>
<img src="/img/image-generation/screenshot_001.png">
<figcaption>Stability AI's <a href="https://huggingface.co/stabilityai/sdxl-turbo">SDXL-Turbo</a> model card</figcaption>
</figure>
<!-- <figure> -->
<!-- <img src="/img/image-generation/screenshot_004.png"> -->
<!-- <figcaption>Model cards often specify terms of use</figcaption> -->
<!-- </figure> -->
<figure>
<img src="/img/image-generation/screenshot_005.png">
<figcaption>Model cards specify restrictions, limitations, and recommendations.</figcaption>
</figure>

<p><a href="https://civitai.com/">Civit AI</a> offers a search tool for finding models that are already fine-tuned to produce a specific style.</p>
<figure>
<img src="/img/image-generation/screenshot_002.png">
<figcaption>Searching for a Pixel Art model on Civit AI</figcaption>
</figure>

<!-- TOC --><a name="conditioning-and-control"></a>
<h2 id="conditioning-and-control">Conditioning and Control</h2>
<p>The most basic form of image generation is called <em>unconditional image generation</em>. Unconditional image generation means producing images that look like a random sample of the model&#39;s training data, with no additional input. If our training set contains pictures of cats, our model will generate pictures of cats. If our training set contains pictures of boats, our model will generate pictures of boats. </p>
<p>The real power of diffusion models comes from our ability to <em>condition</em> on various types of input data in order to tailor the output to our specific needs. When models make use of multiple types of data, we call them <strong>multi-modal</strong>. We&#39;ll consider a few examples.</p>
<p><a href="https://arxiv.org/abs/2103.00020"><strong>CLIP</strong></a> and <a href="https://arxiv.org/abs/2112.10741"><strong>GLIDE</strong></a> allow models to be conditioned by text, enabling tasks like <code>Text-to-Image</code> and <code>Inpainting</code>.</p>
<figure>
<img src="/img/image-generation/screenshot_013.png">
<figcaption>Text-to-Image powered by GLIDE</figcaption>
</figure>

<figure>
<img src="/img/image-generation/screenshot_014.png">
<figcaption>Inpainting powered by GLIDE</figcaption>
</figure>


<p>Fine-tuning and transfer learning via techniques like <a href="https://arxiv.org/abs/2208.12242"><strong>Dreambooth</strong></a> and <a href="https://arxiv.org/abs/2208.01618"><strong>Textual Inversion</strong></a> allow a model to produce outputs of a specific subject or art style. </p>
<figure>
<img src="/img/image-generation/screenshot_015.png">
<figcaption>A model trained to output a specific subject via Dreambooth</figcaption>
</figure>

<p>In some cases, style-transfer can even be achieved <em>without</em> fine-tuning, as shown by <a href="https://arxiv.org/abs/2312.02133"><strong>Style Aligned</strong></a></p>
<figure>
<img src="/img/image-generation/screenshot_016.png">
<figcaption>Style Aligned models can output consistent style without requiring fine-tuning</figcaption>
</figure>

<p><a href="https://arxiv.org/abs/2302.05543"><strong>Control Nets</strong></a> are complementary models that, once trained, allow the output of a diffusion model can be <em>conditioned</em> on (i.e. controlled by) skeletal animation poses, depth maps, segmentation maps, canny edges, and more. <code>Control Nets</code> showed how to go beyond text conditioning and opened up a huge number of previously infeasible use-cases for image generation.</p>
<figure>
<img src="/img/image-generation/screenshot_017.png">
<figcaption>Control Nets augment pre-trained models to allow fine-grained control</figcaption>
</figure>

<!-- TOC --><a name="consistency-for-video"></a>
<h2 id="consistency-for-video">Consistency for video</h2>
<p>We use Control Nets and style transfer so that we can generate images with consistent style and form, but the challenge of consistency goes beyond these techniques. Image-to-video models must additionally achieving consistency across video frames.</p>
<figure>
<img src="/img/image-generation/stable-video-diffusion.gif">
<figcaption><a href="https://huggingface.co/stabilityai/stable-video-diffusion-img2vid">Stable Video Diffusion</a> generates videos from an input image.</figcaption>
</figure>

<p>At the time of this writing, models are still in the early days of being trained to understand and generate video, with companies like RunwayML exploring what they&#39;re calling <a href="https://research.runwayml.com/introducing-general-world-models">General World Models</a>.</p>
<!-- TOC --><a name="performance"></a>
<h2 id="performance">Performance</h2>
<p>Image generation requires significant compute and memory resources. Since entire models are typically loaded into GPU memory, you will need to consider the capabilities and limitations of the systems on which your models run, so as to not exceed them.</p>
<figure>
<img src="/img/image-generation/screenshot_006.png">
<figcaption>A CUDA out-of-memory error</figcaption>
</figure>

<p>Depending on the use case, it may be best prioritize inference speed over image quality, or vice versa.</p>
<p>If a model is too large to fit into GPU memory, <strong>quantization</strong> allows us to lower the memory requirements: If a model made up of 32-bit floats is too large, you can convert all the 32-bit floats to 16-bit floats, 8-bit floats, or even 4-bit floats. Downsizing floats reduces precision, but may allow models to run on less powerful hardward. Quantization of <code>float32</code> models to <code>float16</code> reduces memory requirements considerably without appreciable reduction in image quality.</p>
<p><a href="https://huggingface.co/TheBloke">Tom (&quot;TheBloke&quot;) Jobbins</a> has released over 3000 models on Hugging Face. He uploads variants of popular models: quantized, fine-tuned, and with different file formats. He helps developers onboard into AI and run models on a wide variety of hardware. In August 2023, <a href="https://a16z.com/supporting-the-open-source-ai-community/">a16z awarded Tom a grant</a> for his contributions to open source. </p>
<p>Performance considerations affect everything from training, inference, and offering cloud services to end users. Here are a few references from Hugging Face:</p>
<ul>
<li>The <a href="https://huggingface.co/docs/accelerate/index">accelerate</a> python package simplifies running PyTorch code across multiple devices (a &quot;distributed configuration&quot;).</li>
<li>These jupyter notebooks discuss some techniques / considerations for speeding up inference of diffusion models: <a href="https://huggingface.co/docs/diffusers/tutorials/fast_diffusion#accelerate-inference-of-texttoimage-diffusion-models">Accelerate inference</a>, <a href="https://huggingface.co/docs/diffusers/stable_diffusion#effective-and-efficient-diffusion">Effective and efficient diffusion</a></li>
<li>This section of the <code>diffusers</code> docs considers many aspects of optimization: <a href="https://huggingface.co/docs/diffusers/optimization/opt_overview">Optimization Overview</a></li>
</ul>
<!-- TOC --><a name="technical-foundations"></a>
<h1 id="technical-foundations">Technical Foundations</h1>
<p>There are many ways to generate images, which can make it difficult to learn the technical details. Different researchers and applications come up with their own unique implementations and architectures, making several important decisions along the way.</p>
<p>It helps to learn a few <em>specific</em> end-to-end examples, rather than trying to learn general principles. This way, you can create a solid foundation in your mind and iteratively learn the variations and decisions that each implementation introduces.</p>
<p>We will focus on <code>Stable Diffusion</code>, a popular, open-source, and extensible model for image generation. We will also cover <code>Control Nets</code>, the flexible way of adding various conditioning to a stable diffusion model&#39;s outputs.</p>
<!-- TOC --><a name="prerequisites"></a>
<h2 id="prerequisites">Prerequisites</h2>
<p>Before diving into Stable Diffusion, let&#39;s cover a few important aspects of all neural networks.</p>
<ul>
<li><p><strong>Inputs, Outputs, Loss, Parameters, and Layers/Blocks</strong>: These are the building blocks of any neural network models. <strong>Inputs</strong> are tensors we feed into the model. <strong>Outputs</strong> are what the model produces. <strong>Loss</strong> is a measure used (during training) to quantify how far the model outputs differ from the desired output. Loss is used to update a model&#39;s <strong>parameters</strong>. Parameters are arranged into <strong>layers</strong>, and layers into <strong>blocks</strong>. Each layer and block serves some purpose within the architecture of the neural net. </p>
</li>
<li><p><strong>Training, Inference, and Fine-tuning</strong>: These are the three main phases in the lifecycle of a neural network. <strong>Training</strong> involves learning from data to create a &quot;base&quot; or &quot;foundation&quot; model. <strong>Inference</strong> is using the model to make predictions (i.e. to feed some input to the model and let it generate an output). <strong>Fine-tuning</strong> is an optional training step that adjusts a pre-trained model to specific tasks or datasets.</p>
</li>
<li><p><strong>Model Architectures</strong>: A model <em>architecture</em> refers to the particular configuration of layers, blocks, or even whole neural nets within a larger system. Different architectures excel at different tasks. We&#39;ll discuss a few types of models that are used in a Stable Diffusion pipeline.</p>
</li>
</ul>
<!-- TOC --><a name="stable-diffusion-and-control-nets"></a>
<h2 id="stable-diffusion-and-control-nets">Stable Diffusion and Control Nets</h2>
<p>Stable Diffusion and Control Net have several components that work together to generate images. Architecture diagrams found in these systems&#39; research papers assume the reader already understands the basic components involved. For example, consider the following diagrams from the Stable Diffusion and Control Net papers, respectively.</p>
<figure>
<img src="/img/image-generation/screenshot_019.png">
<figcaption>The architecture of Latent Diffusion Models, with conditioning</figcaption>
</figure>

<figure>
<img src="/img/image-generation/screenshot_018.png">
<figcaption>How Control Nets augment Stable Diffusion's U-Net</figcaption>
</figure>

<p>Our goal is to eventually understand these diagrams. </p>
<p>We will start with a simplified diagram showing the entire architecture. Then we will examine the individual components until we know each component does and how it is trained. </p>
<p>By the end of the article, we hope to understand the diagrams (and text) of the original research papers.</p>
<!-- TOC --><a name="stable-diffusion-inference-diagram"></a>
<h2 id="stable-diffusion-inference-diagram">Stable Diffusion Inference Diagram</h2>
<p>Let&#39;s examine the entire Stable Diffusion pipeline, including text conditioning and a Control Net trained on Canny edge maps.</p>
<figure>
<img src="/img/image-generation/screenshot_020.png">
<figcaption>Images generated by Stable Diffusion with a Control Net trained on Canny edge maps, further conditioned by text prompts.</figcaption>
</figure>

<p>The following diagram illustrates the data flow in Stable Diffusion with a Control Net. Refer to the glossary and followup sections for more details about each component.</p>
<figure>
<img src="/img/image-generation/stable_diffusion_inference_diagram.png">
<figcaption>Data flow diagram of Stable Diffusion with Control Net integration.</figcaption>
</figure>

<p><strong>Inputs and Outputs</strong></p>
<ul>
<li><strong>Input</strong>: Text input and conditional input (Canny edge map).</li>
<li><strong>Output</strong>: Final generated image post reverse diffusion.</li>
</ul>
<p><strong>Process Overview</strong></p>
<ol>
<li><strong>Noisy Latent Initiation</strong>: The process begins with a latent generated from pure noise.</li>
<li><strong>Text and Conditional Inputs Processing</strong>: Text input and a Canny edge map are processed by their respective encoders to produce latent representations.</li>
<li><strong>Combining Latents</strong>: The noise latent, text latent, image latent, and positional encoding (indicating the initial timestep) are combined into a comprehensive &quot;noisy latent&quot;. This combination serves as a comprehensive input to the U-Net.</li>
<li><strong>U-Net Encoding and Decoding</strong>: The combined latents pass through the U-Net encoder, which includes Control Net&#39;s trainable copy. The encoder&#39;s residual connections and Control Net&#39;s zero convolutions feed into the U-Net decoder, which predicts the latent noise, conditioned on the various inputs.</li>
<li><strong>Iterative Reverse Diffusion</strong>: A scheduler adjusts the predicted noise - subtracting a portion of it and adding new noise to the latent. The updated noisy latent, now recombined, re-enters the U-Net for further processing. This loop continues, incrementing the timestep and updating positional encoding each iteration, until a predefined number of steps is reached.</li>
<li><strong>Final Image Generation with VAE Decoder</strong>: The process ends with the VAE decoder transforming the denoised latent into the final image. Notice that the VAE encoder is not required for this (noise-to-image) task, though it was needed during training and would be needed for image-to-image tasks.</li>
</ol>
<p>At this point, in order to deepend your understanding of the pipeline, I recommend reviewing the <a href="#recommended-references">recommended references</a> (if you haven&#39;t already). The remainder of this guide consists of a <a href="#glossary">glossary</a> defining key terms and summaries of the key concepts (in <a href="#diagrams-and-details">&quot;Diagrams and Details&quot;</a>).</p>
<!-- TOC --><a name="recommended-references"></a>
<h1 id="recommended-references">Recommended References</h1>
<p>These resources provide a deeper understanding of the concepts discussed. Of the many resources online, the author found these to be the most helpful and illuminating.</p>
<ul>
<li>Diffusion Models: <a href="https://arxiv.org/abs/1503.03585">Research Paper</a></li>
<li>Latent Diffusion Models: <a href="https://arxiv.org/abs/2112.10752">Research Paper</a></li>
<li>U-Net: <a href="https://arxiv.org/abs/1505.04597">Research Paper</a>, <a href="https://www.youtube.com/watch?v=NhdzGfB1q74">Explainer Video</a></li>
<li>Convolution: <a href="https://www.youtube.com/watch?v=KuXjwB4LzSA">Grant Sanderson&#39;s video &quot;But what is a convolution?&quot;</a></li>
<li>CLIP: <a href="https://openai.com/research/clip">Website</a>, <a href="https://arxiv.org/abs/2103.00020">Research Paper</a></li>
<li>Variational Auto-Encoder: <a href="https://arxiv.org/abs/1312.6114">Research Paper</a>, <a href="https://www.youtube.com/watch?v=9zKuYvjFFS8">Explainer Video</a></li>
<li>Stable Diffusion: <a href="https://www.youtube.com/watch?v=sFztPP9qPRc">Explainer Video</a></li>
<li>ResNets: <a href="https://www.youtube.com/watch?v=o_3mboe1jYI">Explainer Video 1</a>, <a href="https://www.youtube.com/watch?v=Q1JCrG1bJ-A">Explainer Video 2</a></li>
<li>Low-Rank Adaptations: <a href="https://arxiv.org/abs/2106.09685">Research Paper</a></li>
<li>Control Nets: <a href="https://arxiv.org/abs/2302.05543">Research Paper</a>, <a href="https://www.youtube.com/watch?v=Mp-HMQcB_M4">Paper Readthrough Video</a>, <a href="https://github.com/lllyasviel/ControlNet/blob/ed85cd1e25a5ed592f7d8178495b4483de0331bf/docs/faq.md">Note on zero-convolutions</a></li>
<li>History of diffusion models: <a href="https://deepsense.ai/the-recent-rise-of-diffusion-based-models/">deepsense.ai blog post</a></li>
</ul>
<!-- TOC --><a name="glossary"></a>
<h1 id="glossary">Glossary</h1>
<p>It will help to collect definitions several key terms, specifically in the context of their use in Stable Diffusion.</p>
<table>
<thead>
<tr>
<th>Term</th>
<th>Definition</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Diffusion Model</strong></td>
<td>A model trained to generate images via reverse diffusion.</td>
</tr>
<tr>
<td><strong>Forward Diffusion</strong></td>
<td>Gradually adding noise to an image, step by step, &quot;systematically destroying&quot; the information.</td>
</tr>
<tr>
<td><strong>Reverse Diffusion</strong></td>
<td>Removing noise from an image, step by step, until a coherent image remains.</td>
</tr>
<tr>
<td><strong>Conditioning</strong></td>
<td>Using alternative data sources (like text, canny-edges, etc) to alter the generated output of a diffusion model.</td>
</tr>
<tr>
<td><strong>Autoencoder</strong></td>
<td>A model composed of a downsizing encoder and upsizing decoder. The space between the encoder and decoder is the latent space.</td>
</tr>
<tr>
<td><strong>Latent Space</strong></td>
<td>A low-dimensional space of tensors.</td>
</tr>
<tr>
<td><strong>Pixel Space</strong></td>
<td>A high-dimensional space of (image) tensors (with shape <code>height x width x num_channels</code>).</td>
</tr>
<tr>
<td><strong>Latent Diffusion Model</strong></td>
<td>A type of diffusion model that operates in a low-dimensional (and thus, more performant) latent space.</td>
</tr>
<tr>
<td><strong>Stable Diffusion</strong></td>
<td>A set of implementations of latent diffusion models, like SD 1.4, SD 1.5, SDXL, and SDXL Turbo.</td>
</tr>
<tr>
<td><strong>Latents</strong></td>
<td>Tensors in latent space. High-dimensional data (images, text, canny-edges, etc) are converted to latents for processing.</td>
</tr>
<tr>
<td><strong>Variational Autoencoder</strong></td>
<td>An autoencoder ensuring any random noise in latent space will decode to reasonable-looking images.</td>
</tr>
<tr>
<td><strong>VAE Encoder</strong></td>
<td>Converts images to latents.</td>
</tr>
<tr>
<td><strong>VAE Decoder</strong></td>
<td>Converts latents to images.</td>
</tr>
<tr>
<td><strong>U-Net</strong></td>
<td>Core model of Stable Diffusion, receiving image latents and predicting their noise. Composed of an encoder and decoder, skilled at processing spatial hierarchies within images.</td>
</tr>
<tr>
<td><strong>U-Net Encoder</strong></td>
<td>The first half of the U-Net, downsizing images to capture semantic information.</td>
</tr>
<tr>
<td><strong>U-Net Decoder</strong></td>
<td>The second half of the U-Net, upsizing images and recovering details lost by the encoder, augmented with semantic information.</td>
</tr>
<tr>
<td><strong>CLIP</strong></td>
<td>Contrastive language-image pretraining for creating text encoders whose embeddings are close to their associated image embeddings.</td>
</tr>
<tr>
<td><strong>Text Encoder</strong></td>
<td>Converts text to latents, usually trained via CLIP.</td>
</tr>
<tr>
<td><strong>Control Net</strong></td>
<td>An architecture augmenting stable diffusion models for additional input conditioning.</td>
</tr>
<tr>
<td><strong>Control Net Conditioning Encoder</strong></td>
<td>Converts image conditioning data (like canny edge maps) into latent space for a control net.</td>
</tr>
<tr>
<td><strong>Control Net Trainable Copy</strong></td>
<td>A trainable copy of the Stable Diffusion&#39;s U-Net Encoder, connected via &quot;Zero Convolutions&quot; for additional input conditioning without altering the main U-Net.</td>
</tr>
<tr>
<td><strong>Low-Rank Adaptation</strong></td>
<td>A technique for efficiently fine-tuning large models by modifying only a small, low-rank subset of their parameters, enhancing model performance or adapting it to new tasks.</td>
</tr>
<tr>
<td><strong>Dreambooth</strong></td>
<td>A specialized training procedure that personalizes generative models, like diffusion models, to generate content reflecting specific subjects or styles in the training data.</td>
</tr>
<tr>
<td><strong>Textual Inversion</strong></td>
<td>A process of adapting language models to understand and generate text or concepts not covered in their original training, by using specific, targeted training examples.</td>
</tr>
</tbody></table>
<!-- TOC --><a name="diagrams-and-details"></a>
<h1 id="diagrams-and-details">Diagrams and Details</h1>
<p>This section of the guide offers brief explanations and simplified diagrams (inputs and outputs) of the various components involved in a Stable Diffusion pipeline. </p>
<p>It is recommended to consult the <a href="#recommended-resources">recommended resources</a> for better explanations of each of these topics. This section should hopefully serve as a useful reminder and summary of the core concepts.</p>
<!-- TOC --><a name="diffusion-model"></a>
<h2 id="diffusion-model">Diffusion Model</h2>
<figure>
<img src="/img/image-generation/diffusion_model_diagram.png">
<figcaption></figcaption>
</figure>

<p><strong>Input</strong>: Randomly generated noise, (optionally) with non-random conditioning.</p>
<p><strong>Output</strong>: A coherent generated image, produced from several iterative reverse diffusion steps.</p>
<p><strong>Training</strong>: The training process for a diffusion model involves learning to denoise images. Once the model is able to reconstructing the original images from noisy inputs, we use it to generate new images from pure (or conditioned) noise.</p>
<!-- TOC --><a name="autoencoder"></a>
<h2 id="autoencoder">Autoencoder</h2>
<figure>
<img src="/img/image-generation/autoencoder_diagram.png">
<figcaption></figcaption>
</figure>

<p><strong>Input</strong>: Original data that needs to be represented in a compressed form.</p>
<p><strong>Output</strong>: Reconstructed data, which is the decompressed version of the data from the latent space.</p>
<p><strong>Description</strong>: An autoencoder consists of two main parts: an encoder and a decoder. The encoder compresses the input data into a lower-dimensional latent space. The decoder then reconstructs the data from this latent space, aiming to produce an output as close as possible to the original input. Autoencoders are used for tasks like data denoising, dimensionality reduction, and feature learning.</p>
<!-- TOC --><a name="latent-diffusion-model"></a>
<h2 id="latent-diffusion-model">Latent Diffusion Model</h2>
<figure>
<img src="/img/image-generation/latent_diffusion_model_diagram.png">
<figcaption></figcaption>
</figure>

<p><strong>Input</strong>: Latent noise, a lower-dimensional representation compared to full-resolution noise.</p>
<p><strong>Output</strong>: A generated latent image, which is a lower-dimensional representation of the desired output image.</p>
<p><strong>Description</strong>: The Latent Diffusion Model operates in a latent space, which is a compressed, lower-dimensional representation of the image data. This approach allows for more efficient processing and generation of images. The model learns to convert latent noise into a coherent latent image, which can then be transformed into a high-resolution image using other model components like decoders.</p>
<!-- TOC --><a name="variational-autoencoder-vae"></a>
<h2 id="variational-autoencoder-vae">Variational Autoencoder (VAE)</h2>
<figure>
<img src="/img/image-generation/variational_autoencoder_diagram.png">
<figcaption></figcaption>
</figure>

<p><strong>Input</strong>: Original data for encoding into a latent representation.</p>
<p><strong>Output</strong>: Reconstructed data, aimed to be as close to the original input as possible.</p>
<p><strong>Description</strong>: A Variational Autoencoder is a type of autoencoder that introduces randomness in its encoding process. The encoder outputs a mean (μ) and variance (σ) for the latent representation. A random variable (ε) is then used to sample from this distribution, ensuring that the latent space can decode to a variety of similar but slightly different outputs. This characteristic makes VAEs particularly useful for generating new data that resembles the training data.</p>
<!-- TOC --><a name="u-net"></a>
<h2 id="u-net">U-Net</h2>
<figure>
<img src="/img/image-generation/unet_model_diagram.png">
<figcaption></figcaption>
</figure>

<p><strong>Input</strong>: Image latents, which are lower-dimensional representations of images.</p>
<p><strong>Output</strong>: Predicted image latents, mirroring the type and format of the input.</p>
<p><strong>Description</strong>: The U-Net architecture is integral to the Stable Diffusion model. It consists of an encoder, which compresses the image latents, and a decoder, which reconstructs the latents back to their original form. The U-Net&#39;s structure enables it to efficiently process and understand spatial hierarchies within images. This makes it highly effective for tasks like image segmentation, denoising, and super-resolution.</p>
<!-- TOC --><a name="clip-contrastive-language-image-pretraining"></a>
<h2 id="clip-contrastive-language-image-pretraining">CLIP (Contrastive Language-Image Pretraining)</h2>
<figure>
<img src="/img/image-generation/clip_model_diagram.png">
<figcaption></figcaption>
</figure>

<p><strong>Input</strong>: Text and corresponding images.</p>
<p><strong>Output</strong>: Text and image embeddings that are closely aligned in the embedding space.</p>
<p><strong>Description</strong>: CLIP involves two encoders - one for text and one for images. The text encoder converts text inputs into embeddings, while the image encoder does the same for images. The core idea of CLIP is to train these encoders in a contrastive learning framework so that the embeddings of text and images that are semantically related are closer in the embedding space. This makes CLIP highly effective for tasks like zero-shot classification, where the model can recognize objects it hasn&#39;t explicitly been trained on.</p>
<!-- TOC --><a name="text-encoder"></a>
<h2 id="text-encoder">Text Encoder</h2>
<figure>
<img src="/img/image-generation/text_encoder_diagram.png">
<figcaption></figcaption>
</figure>

<p><strong>Input</strong>: Raw text data.</p>
<p><strong>Output</strong>: Latent representations of the text.</p>
<p><strong>Description</strong>: A Text Encoder is a model that converts raw text into a latent, typically lower-dimensional, representation. These text latents are used in various applications, including natural language processing tasks and models like CLIP, where text embeddings need to be closely aligned with image embeddings for effective cross-modal learning. The text encoder is usually trained to capture the semantic essence of the input text, making it valuable for tasks like text classification, sentiment analysis, and more.</p>
<!-- TOC --><a name="control-net-conditioning-encoder"></a>
<h2 id="control-net-conditioning-encoder">Control Net Conditioning Encoder</h2>
<figure>
<img src="/img/image-generation/control_net_conditioning_encoder_diagram.png">
<figcaption></figcaption>
</figure>

<p><strong>Input</strong>: Image conditioning data, such as Canny edge maps or other processed image forms.</p>
<p><strong>Output</strong>: Latent space representation of the conditioning data.</p>
<p><strong>Description</strong>: The Control Net Conditioning Encoder is part of a control net system that processes additional image conditioning data into a latent representation. This encoder transforms specific forms of image data, like edge maps, into a format compatible with the model&#39;s latent space, enhancing the model&#39;s understanding and manipulation of image features. This component is crucial for models that require fine-grained control over image generation or modification.</p>
<!-- TOC --><a name="control-net-trainable-copy"></a>
<h2 id="control-net-trainable-copy">Control Net Trainable Copy</h2>
<figure>
<img src="/img/image-generation/control_net_trainable_copy_diagram.png">
<figcaption></figcaption>
</figure>

<p><strong>Input</strong>: Various additional inputs, including text and images.</p>
<p><strong>Output</strong>: Enhanced image latents, incorporating additional input features.</p>
<p><strong>Description</strong>: The Control Net Trainable Copy is a unique component in the Stable Diffusion architecture. It is a trainable copy of the U-Net Encoder, connected to the original Stable Diffusion&#39;s U-Net via Zero Convolutions. This setup allows the model to integrate additional inputs (like text or specific image features) into the generation process without altering the original, high-quality U-Net weights. This mechanism is key for adapting the model to new conditions or features while maintaining the integrity of the original model&#39;s capabilities.</p>
<!-- TOC --><a name="low-rank-adaptation-lora"></a>
<h2 id="low-rank-adaptation-lora">Low-Rank Adaptation (LoRA)</h2>
<figure>
<img src="/img/image-generation/low_rank_adaptation_diagram.png">
<figcaption></figcaption>
</figure>

<p><strong>Input</strong>: Original parameters of a pre-trained model.</p>
<p><strong>Output</strong>: Adapted model parameters, with updates focused on specific aspects.</p>
<p><strong>Description</strong>: Low-Rank Adaptation (LoRA) is a technique for fine-tuning pre-trained models in a parameter-efficient manner. Instead of updating all parameters, LoRA focuses on adapting a small subset, typically through low-rank matrices. This approach allows for efficient and targeted modifications of the model, often used to adapt large models to specific tasks or datasets without the computational cost of full model retraining.</p>
<!-- TOC --><a name="dreambooth"></a>
<h2 id="dreambooth">Dreambooth</h2>
<figure>
<img src="/img/image-generation/dreambooth_diagram.png">
<figcaption></figcaption>
</figure>

<p><strong>Input</strong>: A set of target images and a specified reference class.</p>
<p><strong>Output</strong>: A generative model fine-tuned to generate images that include characteristics of the target images.</p>
<p><strong>Description</strong>: Dreambooth is a technique used to fine-tune a pretrained generative model so that it can generate images containing specific characteristics of a given target. This is done by training the model with a set of target images, along with a reference class that the targets belong to. The result is a model capable of creating new images that maintain the essence of the target images, allowing for personalized or targeted image generation.</p>
<!-- TOC --><a name="textual-inversion"></a>
<h2 id="textual-inversion">Textual Inversion</h2>
<figure>
<img src="/img/image-generation/textual_inversion_diagram.png">
<figcaption></figcaption>
</figure>

<p><strong>Input</strong>: A set of images depicting a specific concept and corresponding base text prompts.</p>
<p><strong>Output</strong>: A language model adapted to understand and generate text related to the new, specific concept.</p>
<p><strong>Description</strong>: Textual Inversion is a process where a pretrained language model is adapted to understand a new concept by training it with a set of images and associated text prompts. This method allows the model to incorporate a specific, often niche, concept into its understanding and generation capabilities. As a result, the model becomes more versatile in generating text that accurately reflects the new concept, enhancing its applicability to specialized or personalized tasks.</p>
<!-- TOC --><a name="the-u-net-architecture-continued"></a>
<h2 id="the-u-net-architecture-continued">The U-Net Architecture (continued)</h2>
<!-- TOC --><a name="overview"></a>
<h3 id="overview">Overview</h3>
<p>The U-Net architecture, originally designed for biomedical image segmentation, has become a cornerstone in image generation models. It is constructed from a series of downsampling an upsampling layers connected via skip connections, which allows it to process images with an awareness of spatial hierarchies. Its name comes from the &quot;U&quot; shape of its data flow diagram:</p>
<img src="/img/image-generation/screenshot_008.png">

<!-- TOC --><a name="key-concepts"></a>
<h3 id="key-concepts">Key Concepts</h3>
<ul>
<li><strong>Inputs and Outputs</strong>: U-Nets take images as input and produce images (of the same height and width) as output. Their output might be segementation maps, canny edge maps, or whatever else they&#39;re trained to produce.</li>
<li><strong>Convolution Layers</strong>: These layers apply a convolution operation to the input, capturing local dependencies and learning features from the data. In <a href="https://www.youtube.com/watch?v=KuXjwB4LzSA"><em>But what is a convolution</em></a>, Grant Sanderson provides an <em>excellent</em> visual explanation of convolutions. </li>
<li><strong>Downsampling and Upsampling</strong>: Downsampling reduces the spatial dimensions (height and width) of the image, helping the model to abstract and learn higher-level features. Upsampling, conversely, increases the spatial dimensions, aiding in reconstructing the finer details of the image. </li>
<li><strong>Residual Connections</strong>: These connect layers of equal resolution in the downsampling and upsampling paths, allowing the model to preserve high-resolution features throughout the network. As with residual networks, these connections help alleviate the vanishing gradient problem, allowing deeper networks to be trained more effectively.</li>
</ul>
<!-- TOC --><a name="the-variational-autoencoder-vae-continued"></a>
<h2 id="the-variational-autoencoder-vae-continued">The Variational Autoencoder (VAE) (continued)</h2>
<!-- TOC --><a name="overview-1"></a>
<h3 id="overview-1">Overview</h3>
<p>U-Nets are a great start, but training and inference on high-dimensional RGB images is too computationally expensive. We need a way to simplify.</p>
<p>Enter the auto-encoder. Autoencoders learn to encode data into a low-dimensional &quot;latent space&quot; and then decode from this space back to the original data. Unlike traditional <em>entropy-based</em> compression, autoencoders&#39; lossy compression algorithm is trained specifically for the data in their training set. </p>
<p>An autoencoder is naturally broken into two halves: the encoder and the decoder. Once we have a trained autoencoder, we can use the encoder to compress high-resolution images into latent space and we can use the decoder to &quot;decompress&quot; tensors from the latent space back to high-resolution images.</p>
<p>We will embed a U-Net between the encoder and decoder of the VAE, so that the U-Net operates entirely in the latent space. (In other words, we do not directly feed high-resolution images to the U-Net during training or inference. We pre-process each image using the VAE&#39;s encoder.)</p>
<p>For our purposes, the &quot;variational&quot; part of VAEs is not a particularly important detail. <em>Variational</em> auto-encoders ensure that the latent space of our auto-encoder has certain desireable properties, like having each dimension of the latent space correspond to &quot;human-interpretable&quot; changes to the images, and using fewer total dimensions when possible. </p>
<!-- TOC --><a name="key-concepts-1"></a>
<h3 id="key-concepts-1">Key Concepts</h3>
<ul>
<li><strong>Latent Space Representation</strong>: VAEs compress input data into a lower-dimensional space, capturing the essence of the data in a more compact form.</li>
<li><strong>Reconstruction Loss</strong>: The VAE&#39;s loss function ensures that the decoded data matches the original input as closely as possible.</li>
<li><strong>KL Divergence</strong>: The VAE&#39;s loss function also regularizes the encoding space so that encodings follow a desired distribution (typically a Gaussian).</li>
</ul>
<!-- TOC --><a name="noise-timesteps-schedulers"></a>
<h2 id="noise-timesteps-schedulers">Noise, Timesteps, Schedulers</h2>
<!-- TOC --><a name="overview-2"></a>
<h3 id="overview-2">Overview</h3>
<p>In diffusion models, noise plays a central role in transforming images. Timesteps and schedulers manage how noise is added and removed, influencing the model&#39;s efficiency and the quality of generated images.</p>
<!-- TOC --><a name="key-concepts-2"></a>
<h3 id="key-concepts-2">Key Concepts</h3>
<ul>
<li><strong>Gaussian Noise</strong>: This is the type of noise typically added to images in diffusion models. It follows a Gaussian (or normal) distribution.</li>
<li><strong>Timesteps</strong>: These represent discrete steps in the noise addition or removal process. Each timestep corresponds to a certain level of noise in the image.</li>
<li><strong>Schedulers</strong>: These algorithms determine the progression and pattern of timesteps, impacting the trade-off between image fidelity and computational requirements.</li>
</ul>
<!-- TOC --><a name="text-encoder-1"></a>
<h2 id="text-encoder-1">Text Encoder</h2>
<!-- TOC --><a name="overview-3"></a>
<h3 id="overview-3">Overview</h3>
<p>Text encoders in image generation models convert textual descriptions into a format that the model can use to guide the image generation process. </p>
<!-- TOC --><a name="key-concepts-3"></a>
<h3 id="key-concepts-3">Key Concepts</h3>
<ul>
<li><strong>Embeddings</strong>: The text encoder converts text into a dense vector representation, capturing the semantic meaning in a form suitable for the model.</li>
<li><strong>Conditioning</strong>: The embeddings are used to condition the image generation process, aligning the output with the textual description.</li>
<li><strong>CLIP</strong>: A specific type of text encoder that aligns text and image representations, facilitating more accurate text-to-image generation.</li>
</ul>
<!-- TOC --><a name="fine-tuning-techniques"></a>
<h2 id="fine-tuning-techniques">Fine-Tuning Techniques</h2>
<!-- TOC --><a name="overview-4"></a>
<h3 id="overview-4">Overview</h3>
<p>Fine-tuning involves adjusting a pre-trained model to better suit specific needs or styles. This can be done through various methods, each targeting different aspects of the model.</p>
<!-- TOC --><a name="key-concepts-4"></a>
<h3 id="key-concepts-4">Key Concepts</h3>
<ul>
<li><strong>Dreambooth &amp; Textual Inversion</strong>: Techniques for personalizing models to generate images in a specific style or of a specific subject.</li>
<li><strong>Low-Rank Adaptations</strong>: Modifying a small subset of the model&#39;s parameters to fine-tune its outputs without the need for extensive retraining.</li>
</ul>
